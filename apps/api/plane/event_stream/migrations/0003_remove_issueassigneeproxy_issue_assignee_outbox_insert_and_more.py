# Generated by Django 4.2.22 on 2025-08-11 13:57

from django.db import migrations
import pgtrigger.compiler
import pgtrigger.migrations


class Migration(migrations.Migration):

    dependencies = [
        ("event_stream", "0002_alter_outbox_initiator_id"),
    ]

    operations = [
        pgtrigger.migrations.RemoveTrigger(
            model_name="issueassigneeproxy",
            name="issue_assignee_outbox_insert",
        ),
        pgtrigger.migrations.RemoveTrigger(
            model_name="issueassigneeproxy",
            name="issue_assignee_outbox_update",
        ),
        pgtrigger.migrations.RemoveTrigger(
            model_name="issuelabelproxy",
            name="issue_label_outbox_insert",
        ),
        pgtrigger.migrations.RemoveTrigger(
            model_name="issuelabelproxy",
            name="issue_label_outbox_update",
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="issueassigneeproxy",
            trigger=pgtrigger.compiler.Trigger(
                name="issue_assignee_outbox_insert",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    func="\n                DECLARE\n                    event_type_name TEXT;\n                    enriched_data JSONB;\n                    assignee_ids JSONB;\n                    previous_assignee_ids JSONB;\n                    label_ids JSONB;\n                    issue_data JSONB;\n                BEGIN\n                    -- Determine event type based on issue type\n                    SELECT \n                        CASE \n                            WHEN i.type_id IS NULL THEN 'issue.assignee.added'\n                            WHEN it.is_epic = true THEN 'epic.assignee.added'\n                            ELSE 'issue.assignee.added'\n                        END\n                    INTO event_type_name\n                    FROM issues i\n                    LEFT JOIN issue_types it ON it.id = i.type_id\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- If no issue found, default to 'issue.assignee.added'\n                    IF event_type_name IS NULL THEN\n                        event_type_name := 'issue.assignee.added';\n                    END IF;\n                    \n                    -- Get the complete issue data (excluding description fields)\n                    SELECT to_jsonb(i) - 'description_html' - 'description_binary' - 'description' - 'description_stripped'\n                    INTO issue_data\n                    FROM issues i\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- Fetch ALL current assignee IDs (including the newly added one)\n                    SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                    INTO assignee_ids\n                    FROM issue_assignees ia\n                    WHERE ia.issue_id = NEW.issue_id AND ia.deleted_at IS NULL;\n                    \n                    -- Fetch previous assignee IDs (excluding the newly added one)\n                    SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                    INTO previous_assignee_ids\n                    FROM issue_assignees ia\n                    WHERE ia.issue_id = NEW.issue_id AND ia.deleted_at IS NULL AND ia.id != NEW.id;\n                    \n                    -- Fetch label IDs\n                    SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                    INTO label_ids\n                    FROM issue_labels il\n                    WHERE il.issue_id = NEW.issue_id AND il.deleted_at IS NULL;\n                    \n                    -- Create enriched data with complete issue, ALL assignee IDs (including new one), and label IDs\n                    enriched_data := issue_data || jsonb_build_object(\n                            'assignee_ids', assignee_ids,\n                            'label_ids', label_ids\n                    );\n                    \n                    -- Create previous attributes with only the previous assignee IDs\n                    BEGIN\n                        INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                        VALUES (\n                            gen_random_uuid(),\n                            event_type_name,\n                            'issue_assignee',\n                            NEW.issue_id,\n                            NEW.workspace_id,\n                            NEW.project_id,\n                            jsonb_build_object('data', enriched_data, 'previous_attributes', jsonb_build_object('assignee_ids', previous_assignee_ids)),\n                            now(),\n                            NEW.created_by_id,\n                            COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                        )\n                        ON CONFLICT DO NOTHING;\n                    EXCEPTION\n                        WHEN others THEN\n                            RAISE WARNING 'Outbox insert failed for issue_assignee %, reason: %',\n                                         NEW.issue_id, SQLERRM;\n                    END;\n                    RETURN NEW;\n                END;\n                ",
                    hash="fb9078084f95a0bcc244f461ab1a4660e161b4de",
                    operation="INSERT",
                    pgid="pgtrigger_issue_assignee_outbox_insert_51e4c",
                    table="issue_assignees",
                    when="AFTER",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="issueassigneeproxy",
            trigger=pgtrigger.compiler.Trigger(
                name="issue_assignee_outbox_update",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    func="\n                DECLARE\n                    event_type_name TEXT;\n                    enriched_data JSONB;\n                    current_assignee_ids JSONB;\n                    previous_assignee_ids JSONB;\n                    label_ids JSONB;\n                    issue_data JSONB;\n                BEGIN\n                    -- Only trigger on soft delete (deleted_at changing from NULL to NOT NULL)\n                    IF OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL THEN\n                        -- Determine event type based on issue type\n                        SELECT \n                            CASE \n                                WHEN i.type_id IS NULL THEN 'issue.assignee.removed'\n                                WHEN it.is_epic = true THEN 'epic.assignee.removed'\n                                ELSE 'issue.assignee.removed'\n                            END\n                        INTO event_type_name\n                        FROM issues i\n                        LEFT JOIN issue_types it ON it.id = i.type_id\n                        WHERE i.id = OLD.issue_id;\n                        \n                        -- If no issue found, default to 'issue.assignee.removed'\n                        IF event_type_name IS NULL THEN\n                            event_type_name := 'issue.assignee.removed';\n                        END IF;\n                        \n                        -- Get the complete issue data (excluding description fields)\n                        SELECT to_jsonb(i) - 'description_html' - 'description_binary' - 'description' - 'description_stripped'\n                        INTO issue_data\n                        FROM issues i\n                        WHERE i.id = OLD.issue_id;\n                        \n                        -- Fetch current assignee IDs (excluding the one being removed)\n                        SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                        INTO current_assignee_ids\n                        FROM issue_assignees ia\n                        WHERE ia.issue_id = OLD.issue_id AND ia.deleted_at IS NULL AND ia.id != OLD.id;\n                        \n                        -- Fetch ALL assignee IDs (including the one being removed) for previous_attributes\n                        SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                        INTO previous_assignee_ids\n                        FROM issue_assignees ia\n                        WHERE ia.issue_id = OLD.issue_id AND ia.deleted_at IS NULL;\n                        \n                        -- Fetch label IDs\n                        SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                        INTO label_ids\n                        FROM issue_labels il\n                        WHERE il.issue_id = OLD.issue_id AND il.deleted_at IS NULL;\n                        \n                        -- Create enriched data with complete issue and current assignee IDs (after removal)\n                        enriched_data := issue_data || jsonb_build_object(\n                                'assignee_ids', current_assignee_ids,\n                                'label_ids', label_ids\n                        );\n                        \n                        -- Create previous attributes with only the previous assignee IDs\n                        BEGIN\n                            INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                            VALUES (\n                                gen_random_uuid(),\n                                event_type_name,\n                                'issue_assignee',\n                                OLD.issue_id,\n                                OLD.workspace_id,\n                                OLD.project_id,\n                                jsonb_build_object('data', enriched_data, 'previous_attributes', jsonb_build_object('assignee_ids', previous_assignee_ids)),\n                                now(),\n                                NEW.updated_by_id,\n                                COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                            )\n                            ON CONFLICT DO NOTHING;\n                        EXCEPTION\n                            WHEN others THEN\n                                RAISE WARNING 'Outbox delete-event failed for issue_assignee %, reason: %',\n                                             OLD.issue_id, SQLERRM;\n                        END;\n                    END IF;\n                    RETURN NEW;\n                END;\n                ",
                    hash="5431a3c2730df15b182fa5344f836d49789827fa",
                    operation="UPDATE",
                    pgid="pgtrigger_issue_assignee_outbox_update_97b55",
                    table="issue_assignees",
                    when="BEFORE",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="issuelabelproxy",
            trigger=pgtrigger.compiler.Trigger(
                name="issue_label_outbox_insert",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    func="\n                DECLARE\n                    event_type_name TEXT;\n                    enriched_data JSONB;\n                    assignee_ids JSONB;\n                    label_ids JSONB;\n                    previous_label_ids JSONB;\n                    issue_data JSONB;\n                BEGIN\n                    -- Determine event type based on issue type\n                    SELECT \n                        CASE \n                            WHEN i.type_id IS NULL THEN 'issue.label.added'\n                            WHEN it.is_epic = true THEN 'epic.label.added'\n                            ELSE 'issue.label.added'\n                        END\n                    INTO event_type_name\n                    FROM issues i\n                    LEFT JOIN issue_types it ON it.id = i.type_id\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- If no issue found, default to 'issue.label.added'\n                    IF event_type_name IS NULL THEN\n                        event_type_name := 'issue.label.added';\n                    END IF;\n                    \n                    -- Get the complete issue data (excluding description fields)\n                    SELECT to_jsonb(i) - 'description_html' - 'description_binary' - 'description' - 'description_stripped'\n                    INTO issue_data\n                    FROM issues i\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- Fetch assignee IDs\n                    SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                    INTO assignee_ids\n                    FROM issue_assignees ia\n                    WHERE ia.issue_id = NEW.issue_id AND ia.deleted_at IS NULL;\n                    \n                    -- Fetch ALL current label IDs (including the newly added one)\n                    SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                    INTO label_ids\n                    FROM issue_labels il\n                    WHERE il.issue_id = NEW.issue_id AND il.deleted_at IS NULL;\n                    \n                    -- Fetch previous label IDs (excluding the newly added one)\n                    SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                    INTO previous_label_ids\n                    FROM issue_labels il\n                    WHERE il.issue_id = NEW.issue_id AND il.deleted_at IS NULL AND il.id != NEW.id;\n                    \n                    -- Create enriched data with complete issue, assignee IDs, and ALL label IDs (including new one)\n                    enriched_data := issue_data || jsonb_build_object(\n                            'assignee_ids', assignee_ids,\n                            'label_ids', label_ids\n                    );\n                    \n                    -- Create previous attributes with only the previous label IDs\n                    BEGIN\n                        INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                        VALUES (\n                            gen_random_uuid(),\n                            event_type_name,\n                            'issue_label',\n                            NEW.issue_id,\n                            NEW.workspace_id,\n                            NEW.project_id,\n                            jsonb_build_object('data', enriched_data, 'previous_attributes', jsonb_build_object('label_ids', previous_label_ids)),\n                            now(),\n                            NEW.created_by_id,\n                            COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                        )\n                        ON CONFLICT DO NOTHING;\n                    EXCEPTION\n                        WHEN others THEN\n                            RAISE WARNING 'Outbox insert failed for issue_label %, reason: %',\n                                         NEW.issue_id, SQLERRM;\n                    END;\n                    RETURN NEW;\n                END;\n                ",
                    hash="8e775687be295714109f924ab6f7f54540ea0256",
                    operation="INSERT",
                    pgid="pgtrigger_issue_label_outbox_insert_a8b0d",
                    table="issue_labels",
                    when="AFTER",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="issuelabelproxy",
            trigger=pgtrigger.compiler.Trigger(
                name="issue_label_outbox_update",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    func="\n                DECLARE\n                    event_type_name TEXT;\n                    enriched_data JSONB;\n                    assignee_ids JSONB;\n                    current_label_ids JSONB;\n                    previous_label_ids JSONB;\n                    issue_data JSONB;\n                BEGIN\n                    -- Only trigger on soft delete (deleted_at changing from NULL to NOT NULL)\n                    IF OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL THEN\n                        -- Determine event type based on issue type\n                        SELECT \n                            CASE \n                                WHEN i.type_id IS NULL THEN 'issue.label.removed'\n                                WHEN it.is_epic = true THEN 'epic.label.removed'\n                                ELSE 'issue.label.removed'\n                            END\n                        INTO event_type_name\n                        FROM issues i\n                        LEFT JOIN issue_types it ON it.id = i.type_id\n                        WHERE i.id = OLD.issue_id;\n                        \n                        -- If no issue found, default to 'issue.label.removed'\n                        IF event_type_name IS NULL THEN\n                            event_type_name := 'issue.label.removed';\n                        END IF;\n                        \n                        -- Get the complete issue data (excluding description fields)\n                        SELECT to_jsonb(i) - 'description_html' - 'description_binary' - 'description' - 'description_stripped'\n                        INTO issue_data\n                        FROM issues i\n                        WHERE i.id = OLD.issue_id;\n                        \n                        -- Fetch assignee IDs\n                        SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                        INTO assignee_ids\n                        FROM issue_assignees ia\n                        WHERE ia.issue_id = OLD.issue_id AND ia.deleted_at IS NULL;\n                        \n                        -- Fetch current label IDs (excluding the one being removed)\n                        SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                        INTO current_label_ids\n                        FROM issue_labels il\n                        WHERE il.issue_id = OLD.issue_id AND il.deleted_at IS NULL AND il.id != OLD.id;\n                        \n                        -- Fetch ALL label IDs (including the one being removed) for previous_attributes\n                        SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                        INTO previous_label_ids\n                        FROM issue_labels il\n                        WHERE il.issue_id = OLD.issue_id AND il.deleted_at IS NULL;\n                        \n                        -- Create enriched data with complete issue, assignee IDs, and current label IDs (after removal)\n                        enriched_data := issue_data || jsonb_build_object(\n                            'assignee_ids', assignee_ids,\n                            'label_ids', current_label_ids\n                        );\n                        \n                        -- Create previous attributes with only the previous label IDs (including the removed one)\n                        BEGIN\n                            INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                            VALUES (\n                                gen_random_uuid(),\n                                event_type_name,\n                                'issue_label',\n                                OLD.issue_id,\n                                OLD.workspace_id,\n                                OLD.project_id,\n                                jsonb_build_object('data', enriched_data, 'previous_attributes', jsonb_build_object('label_ids', previous_label_ids)),\n                                now(),\n                                NEW.updated_by_id,\n                                COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                            )\n                            ON CONFLICT DO NOTHING;\n                        EXCEPTION\n                            WHEN others THEN\n                                RAISE WARNING 'Outbox delete-event failed for issue_label %, reason: %',\n                                         OLD.issue_id, SQLERRM;\n                        END;\n                    END IF;\n                    RETURN NEW;\n                END;\n                ",
                    hash="d95ed7ede7029dd8d4bb8e24f69377de71d6291d",
                    operation="UPDATE",
                    pgid="pgtrigger_issue_label_outbox_update_47e56",
                    table="issue_labels",
                    when="BEFORE",
                ),
            ),
        ),
    ]
