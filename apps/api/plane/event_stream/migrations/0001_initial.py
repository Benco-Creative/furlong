# Generated by Django 4.2.22 on 2025-08-08 06:42

from django.db import migrations, models
import django.db.models.manager
import django.utils.timezone
import pgtrigger.compiler
import pgtrigger.migrations
import uuid


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ("db", "0100_profile_has_marketing_email_consent_and_more"),
    ]

    operations = [
        migrations.CreateModel(
            name="CycleIssueProxy",
            fields=[],
            options={
                "proxy": True,
                "indexes": [],
                "constraints": [],
            },
            bases=("db.cycleissue",),
        ),
        migrations.CreateModel(
            name="IssueAssigneeProxy",
            fields=[],
            options={
                "proxy": True,
                "indexes": [],
                "constraints": [],
            },
            bases=("db.issueassignee",),
        ),
        migrations.CreateModel(
            name="IssueAttachmentProxy",
            fields=[],
            options={
                "proxy": True,
                "indexes": [],
                "constraints": [],
            },
            bases=("db.fileasset",),
        ),
        migrations.CreateModel(
            name="IssueCommentProxy",
            fields=[],
            options={
                "proxy": True,
                "indexes": [],
                "constraints": [],
            },
            bases=("db.issuecomment",),
        ),
        migrations.CreateModel(
            name="IssueLabelProxy",
            fields=[],
            options={
                "proxy": True,
                "indexes": [],
                "constraints": [],
            },
            bases=("db.issuelabel",),
        ),
        migrations.CreateModel(
            name="IssueLinkProxy",
            fields=[],
            options={
                "proxy": True,
                "indexes": [],
                "constraints": [],
            },
            bases=("db.issuelink",),
        ),
        migrations.CreateModel(
            name="IssueProxy",
            fields=[],
            options={
                "proxy": True,
                "indexes": [],
                "constraints": [],
            },
            bases=("db.issue",),
            managers=[
                ("issue_objects", django.db.models.manager.Manager()),
            ],
        ),
        migrations.CreateModel(
            name="IssueRelationProxy",
            fields=[],
            options={
                "proxy": True,
                "indexes": [],
                "constraints": [],
            },
            bases=("db.issuerelation",),
        ),
        migrations.CreateModel(
            name="ModuleIssueProxy",
            fields=[],
            options={
                "proxy": True,
                "indexes": [],
                "constraints": [],
            },
            bases=("db.moduleissue",),
        ),
        migrations.CreateModel(
            name="Outbox",
            fields=[
                ("id", models.BigAutoField(primary_key=True, serialize=False)),
                (
                    "event_id",
                    models.UUIDField(default=uuid.uuid4, editable=False, unique=True),
                ),
                ("event_type", models.CharField(max_length=255)),
                ("entity_type", models.CharField(max_length=255)),
                ("entity_id", models.UUIDField()),
                ("payload", models.JSONField()),
                ("processed_at", models.DateTimeField(blank=True, null=True)),
                ("created_at", models.DateTimeField(default=django.utils.timezone.now)),
                ("claimed_at", models.DateTimeField(blank=True, null=True)),
                ("workspace_id", models.UUIDField()),
                ("project_id", models.UUIDField()),
                (
                    "initiator_id",
                    models.UUIDField(help_text="The user ID who triggered the event"),
                ),
                ("initiator_type", models.CharField(default="USER", max_length=255)),
            ],
            options={
                "db_table": "outbox",
                "ordering": ["-created_at"],
                "indexes": [
                    models.Index(
                        condition=models.Q(
                            ("claimed_at__isnull", True), ("processed_at__isnull", True)
                        ),
                        fields=["claimed_at", "processed_at", "id"],
                        name="outbox_unclaimed_unprocessed",
                    ),
                    models.Index(
                        condition=models.Q(("processed_at__isnull", False)),
                        fields=["processed_at"],
                        name="outbox_processed_idx",
                    ),
                ],
            },
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="cycleissueproxy",
            trigger=pgtrigger.compiler.Trigger(
                name="cycle_issue_outbox_insert",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    func="\n                BEGIN\n                    BEGIN\n                        -- try to enqueue event; ignore dupes and handle unexpected errors\n                        INSERT INTO outbox (\n                            event_id, event_type, entity_type, entity_id, payload, workspace_id, project_id, created_at, initiator_id, initiator_type\n                        )\n                        VALUES (\n                            gen_random_uuid(),\n                            'issue.cycle.added',\n                            'cycle_issue',\n                            NEW.issue_id,\n                            jsonb_build_object('data', row_to_json(NEW), 'previous_attributes', '{}'),\n                            NEW.workspace_id,\n                            NEW.project_id,\n                            now(),\n                            NEW.created_by_id,\n                            COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                        )\n                        ON CONFLICT DO NOTHING;            -- (optional) skip duplicates\n                    EXCEPTION\n                        WHEN others THEN\n                            -- log but DO NOT re-throw, so the main insert survives\n                            RAISE WARNING 'Outbox insert failed for cycle_issue %, reason: %',\n                                         NEW.issue_id, SQLERRM;\n                    END;\n                    RETURN NEW;\n                END;\n                ",
                    hash="565f83867cb222e250f01b77aa08146fedba230a",
                    operation="INSERT",
                    pgid="pgtrigger_cycle_issue_outbox_insert_66548",
                    table="cycle_issues",
                    when="AFTER",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="cycleissueproxy",
            trigger=pgtrigger.compiler.Trigger(
                name="cycle_issue_outbox_update",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    func="\n                BEGIN\n                    BEGIN\n                        -- Check if this is a soft delete (deleted_at changed from null to not null)\n                        IF OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL THEN\n                            -- This is a soft delete\n                            INSERT INTO outbox (\n                                event_id, event_type, entity_type, entity_id, payload, workspace_id, project_id, created_at, initiator_id, initiator_type\n                            )\n                            VALUES (\n                                gen_random_uuid(),\n                                'issue.cycle.removed',\n                                'cycle_issue',\n                                OLD.issue_id,\n                                jsonb_build_object('data', '{}', 'previous_attributes', row_to_json(OLD)),\n                                OLD.workspace_id,\n                                OLD.project_id,\n                                now(),\n                                NEW.updated_by_id,\n                                COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                            )\n                            ON CONFLICT DO NOTHING;\n                        ELSE\n                            -- This is a regular update - only trigger if cycle_id changed\n                            IF OLD.cycle_id IS DISTINCT FROM NEW.cycle_id THEN\n                                INSERT INTO outbox (\n                                    event_id, event_type, entity_type, entity_id, payload, workspace_id, project_id, created_at, initiator_id, initiator_type\n                                )\n                                VALUES (\n                                    gen_random_uuid(),\n                                    'issue.cycle.moved',\n                                    'cycle_issue',\n                                    NEW.issue_id,\n                                    jsonb_build_object('data', row_to_json(NEW), 'previous_attributes', row_to_json(OLD)),\n                                    NEW.workspace_id,\n                                    NEW.project_id,\n                                    now(),\n                                    NEW.updated_by_id,\n                                    COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                                )\n                                ON CONFLICT DO NOTHING;\n                            END IF;\n                        END IF;\n                    EXCEPTION\n                        WHEN others THEN\n                            RAISE WARNING 'Outbox update-event failed for cycle_issue %, reason: %',\n                                         COALESCE(NEW.issue_id, OLD.issue_id), SQLERRM;\n                    END;\n                    RETURN NEW;\n                END;\n                ",
                    hash="b6ff117b5ac6b5347ea76fb9ea58d4b2f9d027b1",
                    operation="UPDATE",
                    pgid="pgtrigger_cycle_issue_outbox_update_38237",
                    table="cycle_issues",
                    when="AFTER",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="issueassigneeproxy",
            trigger=pgtrigger.compiler.Trigger(
                name="issue_assignee_outbox_insert",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    func="\n                DECLARE\n                    event_type_name TEXT;\n                    enriched_data JSONB;\n                    assignee_ids JSONB;\n                    previous_assignee_ids JSONB;\n                    label_ids JSONB;\n                    issue_data JSONB;\n                BEGIN\n                    -- Determine event type based on issue type\n                    SELECT \n                        CASE \n                            WHEN i.type_id IS NULL THEN 'issue.assignee.added'\n                            WHEN it.is_epic = true THEN 'epic.assignee.added'\n                            ELSE 'issue.assignee.added'\n                        END\n                    INTO event_type_name\n                    FROM issues i\n                    LEFT JOIN issue_types it ON it.id = i.type_id\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- If no issue found, default to 'issue.assignee.added'\n                    IF event_type_name IS NULL THEN\n                        event_type_name := 'issue.assignee.added';\n                    END IF;\n                    \n                    -- Get the complete issue data (excluding description fields)\n                    SELECT to_jsonb(i) - 'description_html' - 'description_binary' - 'description' - 'description_stripped'\n                    INTO issue_data\n                    FROM issues i\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- Fetch ALL current assignee IDs (including the newly added one)\n                    SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                    INTO assignee_ids\n                    FROM issue_assignees ia\n                    WHERE ia.issue_id = NEW.issue_id AND ia.deleted_at IS NULL;\n                    \n                    -- Fetch previous assignee IDs (excluding the newly added one)\n                    SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                    INTO previous_assignee_ids\n                    FROM issue_assignees ia\n                    WHERE ia.issue_id = NEW.issue_id AND ia.deleted_at IS NULL AND ia.id != NEW.id;\n                    \n                    -- Fetch label IDs\n                    SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                    INTO label_ids\n                    FROM issue_labels il\n                    WHERE il.issue_id = NEW.issue_id AND il.deleted_at IS NULL;\n                    \n                    -- Create enriched data with complete issue, ALL assignee IDs (including new one), and label IDs\n                    enriched_data := issue_data || jsonb_build_object(\n                            'assignee_ids', assignee_ids,\n                            'label_ids', label_ids\n                    );\n                    \n                    -- Create previous attributes with assignee IDs that existed before the addition\n                    issue_data := issue_data || jsonb_build_object(\n                            'assignee_ids', previous_assignee_ids,\n                            'label_ids', label_ids\n                    );\n                    \n                    BEGIN\n                        INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                        VALUES (\n                            gen_random_uuid(),\n                            event_type_name,\n                            'issue_assignee',\n                            NEW.issue_id,\n                            NEW.workspace_id,\n                            NEW.project_id,\n                            jsonb_build_object('data', enriched_data, 'previous_attributes', issue_data),\n                            now(),\n                            NEW.created_by_id,\n                            COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                        )\n                        ON CONFLICT DO NOTHING;\n                    EXCEPTION\n                        WHEN others THEN\n                            RAISE WARNING 'Outbox insert failed for issue_assignee %, reason: %',\n                                         NEW.issue_id, SQLERRM;\n                    END;\n                    RETURN NEW;\n                END;\n                ",
                    hash="34aab09d0dad0a9eb732840002f423117fe42cbb",
                    operation="INSERT",
                    pgid="pgtrigger_issue_assignee_outbox_insert_51e4c",
                    table="issue_assignees",
                    when="AFTER",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="issueassigneeproxy",
            trigger=pgtrigger.compiler.Trigger(
                name="issue_assignee_outbox_update",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    func="\n                DECLARE\n                    event_type_name TEXT;\n                    enriched_data JSONB;\n                    current_assignee_ids JSONB;\n                    previous_assignee_ids JSONB;\n                    label_ids JSONB;\n                    issue_data JSONB;\n                    previous_issue_data JSONB;\n                BEGIN\n                    -- Determine event type based on issue type\n                    SELECT \n                        CASE \n                            WHEN i.type_id IS NULL THEN 'issue.assignee.removed'\n                            WHEN it.is_epic = true THEN 'epic.assignee.removed'\n                            ELSE 'issue.assignee.removed'\n                        END\n                    INTO event_type_name\n                    FROM issues i\n                    LEFT JOIN issue_types it ON it.id = i.type_id\n                    WHERE i.id = OLD.issue_id;\n                    \n                    -- If no issue found, default to 'issue.assignee.removed'\n                    IF event_type_name IS NULL THEN\n                        event_type_name := 'issue.assignee.removed';\n                    END IF;\n                    \n                    -- Get the complete issue data (excluding description fields)\n                    SELECT to_jsonb(i) - 'description_html' - 'description_binary' - 'description' - 'description_stripped'\n                    INTO issue_data\n                    FROM issues i\n                    WHERE i.id = OLD.issue_id;\n                    \n                    -- Fetch current assignee IDs (excluding the one being removed)\n                    SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                    INTO current_assignee_ids\n                    FROM issue_assignees ia\n                    WHERE ia.issue_id = OLD.issue_id AND ia.deleted_at IS NULL AND ia.id != OLD.id;\n                    \n                    -- Fetch ALL assignee IDs (including the one being removed) for previous_attributes\n                    SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                    INTO previous_assignee_ids\n                    FROM issue_assignees ia\n                    WHERE ia.issue_id = OLD.issue_id AND ia.deleted_at IS NULL;\n                    \n                    -- Fetch label IDs\n                    SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                    INTO label_ids\n                    FROM issue_labels il\n                    WHERE il.issue_id = OLD.issue_id AND il.deleted_at IS NULL;\n                    \n                    -- Create enriched data with complete issue and current assignee IDs (after removal)\n                    enriched_data := issue_data || jsonb_build_object(\n                            'assignee_ids', current_assignee_ids,\n                            'label_ids', label_ids\n                    );\n                    \n                    -- Create previous attributes with complete issue and ALL assignee IDs (including the removed one)\n                    previous_issue_data := issue_data || jsonb_build_object(\n                            'assignee_ids', previous_assignee_ids,\n                            'label_ids', label_ids\n                    );\n                    \n                    BEGIN\n                        INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                        VALUES (\n                            gen_random_uuid(),\n                            event_type_name,\n                            'issue_assignee',\n                            OLD.issue_id,\n                            OLD.workspace_id,\n                            OLD.project_id,\n                            jsonb_build_object('data', enriched_data, 'previous_attributes', previous_issue_data),\n                            now(),\n                            NEW.updated_by_id,\n                            COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                        )\n                        ON CONFLICT DO NOTHING;\n                    EXCEPTION\n                        WHEN others THEN\n                            RAISE WARNING 'Outbox delete-event failed for issue_assignee %, reason: %',\n                                         OLD.issue_id, SQLERRM;\n                    END;\n                    RETURN OLD;\n                END;\n                ",
                    hash="eaf77930501ace8c7974991b9a86be648dee272d",
                    operation="UPDATE",
                    pgid="pgtrigger_issue_assignee_outbox_update_97b55",
                    table="issue_assignees",
                    when="AFTER",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="issueattachmentproxy",
            trigger=pgtrigger.compiler.Trigger(
                name="issue_attachment_outbox_insert",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    func="\n                DECLARE\n                    event_type_name TEXT;\n                BEGIN\n                    -- Only trigger for ISSUE_ATTACHMENT entity type\n                    IF NEW.entity_type = 'ISSUE_ATTACHMENT' THEN\n                        -- Determine event type based on issue type\n                        SELECT \n                            CASE \n                                WHEN i.type_id IS NULL THEN 'issue.attachment.added'\n                                WHEN it.is_epic = true THEN 'epic.attachment.added'\n                                ELSE 'issue.attachment.added'\n                            END\n                        INTO event_type_name\n                        FROM issues i\n                        LEFT JOIN issue_types it ON it.id = i.type_id\n                        WHERE i.id = NEW.issue_id;\n                        \n                        -- If no issue found, default to 'issue.attachment.added'\n                        IF event_type_name IS NULL THEN\n                            event_type_name := 'issue.attachment.added';\n                        END IF;\n                        \n                        BEGIN\n                            INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                            VALUES (\n                                gen_random_uuid(),\n                                event_type_name,\n                                'issue_attachment',\n                                NEW.issue_id,\n                                NEW.workspace_id,\n                                NEW.project_id,\n                                jsonb_build_object('data', row_to_json(NEW), 'previous_attributes', '{}'),\n                                now(),\n                                NEW.created_by_id,\n                                COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                            )\n                            ON CONFLICT DO NOTHING;\n                        EXCEPTION\n                            WHEN others THEN\n                                RAISE WARNING 'Outbox insert failed for issue_attachment %, reason: %',\n                                             NEW.issue_id, SQLERRM;\n                        END;\n                    END IF;\n                    RETURN NEW;\n                END;\n                ",
                    hash="dfd7cc98782f6f0347bf92d36a021e45899d8c29",
                    operation="INSERT",
                    pgid="pgtrigger_issue_attachment_outbox_insert_b1598",
                    table="file_assets",
                    when="AFTER",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="issueattachmentproxy",
            trigger=pgtrigger.compiler.Trigger(
                name="issue_attachment_outbox_update",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    func="\n                DECLARE\n                    changes JSONB := '{}';\n                    field_name TEXT;\n                    old_value TEXT;\n                    new_value TEXT;\n                    event_type_name TEXT;\n                BEGIN\n                    -- Only trigger for ISSUE_ATTACHMENT entity type\n                    IF NEW.entity_type = 'ISSUE_ATTACHMENT' OR OLD.entity_type = 'ISSUE_ATTACHMENT' THEN\n                        -- Determine event type based on issue type\n                        SELECT \n                            CASE \n                                WHEN i.type_id IS NULL THEN 'issue.attachment.updated'\n                                WHEN it.is_epic = true THEN 'epic.attachment.updated'\n                                ELSE 'issue.attachment.updated'\n                            END\n                        INTO event_type_name\n                        FROM issues i\n                        LEFT JOIN issue_types it ON it.id = i.type_id\n                        WHERE i.id = NEW.issue_id;\n                        \n                        -- If no issue found, default to 'issue.attachment.updated'\n                        IF event_type_name IS NULL THEN\n                            event_type_name := 'issue.attachment.updated';\n                        END IF;\n                        \n                        -- Check if this is a soft delete (deleted_at changed from null to not null)\n                        IF OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL THEN\n                            -- This is a soft delete\n                            -- Determine delete event type based on issue type\n                            SELECT \n                                CASE \n                                    WHEN i.type_id IS NULL THEN 'issue.attachment.removed'\n                                    WHEN it.is_epic = true THEN 'epic.attachment.removed'\n                                    ELSE 'issue.attachment.removed'\n                                END\n                            INTO event_type_name\n                            FROM issues i\n                            LEFT JOIN issue_types it ON it.id = i.type_id\n                            WHERE i.id = OLD.issue_id;\n                            \n                            -- If no issue found, default to 'issue.attachment.removed'\n                            IF event_type_name IS NULL THEN\n                                event_type_name := 'issue.attachment.removed';\n                            END IF;\n                            \n                            BEGIN\n                                INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                                VALUES (\n                                    gen_random_uuid(),\n                                    event_type_name,\n                                    'issue_attachment',\n                                    OLD.issue_id,\n                                    OLD.workspace_id,\n                                    OLD.project_id,\n                                    jsonb_build_object('data', '{}', 'previous_attributes', row_to_json(OLD)),\n                                    now(),\n                                    NEW.updated_by_id,\n                                    COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                                )\n                                ON CONFLICT DO NOTHING;\n                            EXCEPTION\n                                WHEN others THEN\n                                    RAISE WARNING 'Outbox delete failed for issue_attachment %, reason: %',\n                                                 OLD.issue_id, SQLERRM;\n                            END;\n                        ELSE\n                            -- This is a regular update, check for changes\n                            -- Loop through all columns to detect changes\n                            FOR field_name IN \n                                SELECT column_name \n                                FROM information_schema.columns \n                                WHERE table_name = 'file_assets' \n                                AND table_schema = 'public'\n                                AND column_name != 'updated_at'  -- Skip updated_at column\n                            LOOP\n                                -- Get old and new values as text to avoid JSON conversion issues\n                                EXECUTE format('SELECT ($1).%I::text, ($2).%I::text', field_name, field_name) \n                                INTO old_value, new_value \n                                USING OLD, NEW;\n                                \n                                -- If values are different, add to changes\n                                IF old_value IS DISTINCT FROM new_value THEN\n                                    changes := changes || jsonb_build_object(\n                                        field_name, \n                                        old_value\n                                    );\n                                END IF;\n                            END LOOP;\n                            \n                            -- Only insert if there are actual changes\n                            IF jsonb_typeof(changes) = 'object' AND changes != '{}' THEN\n                                BEGIN\n                                    INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                                    VALUES (\n                                        gen_random_uuid(),\n                                        event_type_name, \n                                        'issue_attachment',\n                                        NEW.issue_id,\n                                        NEW.workspace_id,\n                                        NEW.project_id,\n                                        jsonb_build_object(\n                                            'data', row_to_json(NEW),\n                                            'previous_attributes', changes\n                                        ),\n                                        now(),\n                                        NEW.updated_by_id,\n                                        COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                                    )\n                                    ON CONFLICT DO NOTHING;\n                                EXCEPTION\n                                    WHEN others THEN\n                                        RAISE WARNING 'Outbox update failed for issue_attachment %, reason: %',\n                                                     NEW.issue_id, SQLERRM;\n                                END;\n                            END IF;\n                        END IF;\n                    END IF;\n                    \n                    RETURN NEW;\n                END;\n                ",
                    hash="b7cdd5f4da351e7d3b97a99b1212efcb1093a85b",
                    operation="UPDATE",
                    pgid="pgtrigger_issue_attachment_outbox_update_5fc41",
                    table="file_assets",
                    when="AFTER",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="issuecommentproxy",
            trigger=pgtrigger.compiler.Trigger(
                name="issue_comment_outbox_insert",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    func="\n                DECLARE\n                    event_type_name TEXT;\n                    enriched_data JSONB;\n                    assignee_ids JSONB;\n                    label_ids JSONB;\n                    issue_data JSONB;\n                BEGIN\n                    -- Determine event type based on issue type\n                    SELECT \n                        CASE \n                            WHEN i.type_id IS NULL THEN 'issue.comment.created'\n                            WHEN it.is_epic = true THEN 'epic.comment.created'\n                            ELSE 'issue.comment.created'\n                        END\n                    INTO event_type_name\n                    FROM issues i\n                    LEFT JOIN issue_types it ON it.id = i.type_id\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- If no issue found, default to 'issue.comment.created'\n                    IF event_type_name IS NULL THEN\n                        event_type_name := 'issue.comment.created';\n                    END IF;\n                    \n                    -- Get the complete issue data (excluding description fields)\n                    SELECT to_jsonb(i) - 'description_html' - 'description_binary' - 'description' - 'description_stripped'\n                    INTO issue_data\n                    FROM issues i\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- Fetch assignee IDs\n                    SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                    INTO assignee_ids\n                    FROM issue_assignees ia\n                    WHERE ia.issue_id = NEW.issue_id AND ia.deleted_at IS NULL;\n                    \n                    -- Fetch label IDs\n                    SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                    INTO label_ids\n                    FROM issue_labels il\n                    WHERE il.issue_id = NEW.issue_id AND il.deleted_at IS NULL;\n                    \n                    -- Create enriched data with complete issue, assignee IDs, and label IDs\n                    enriched_data := issue_data || jsonb_build_object(\n                        'assignee_ids', assignee_ids,\n                        'label_ids', label_ids,\n                        'comment', row_to_json(NEW)\n                    );\n                    \n                    BEGIN\n                        INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                        VALUES (\n                            gen_random_uuid(),\n                            event_type_name,\n                            'issue',\n                            NEW.issue_id,\n                            NEW.workspace_id,\n                            NEW.project_id,\n                            jsonb_build_object('data', enriched_data, 'previous_attributes', '{}'),\n                            now(),\n                            NEW.created_by_id,\n                            COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                        )\n                        ON CONFLICT DO NOTHING;\n                    EXCEPTION\n                        WHEN others THEN\n                            RAISE WARNING 'Outbox insert failed for issue_comment %, reason: %',\n                                         NEW.issue_id, SQLERRM;\n                    END;\n                    RETURN NEW;\n                END;\n                ",
                    hash="2e57bd2fe5275c8fef7bb8a1f318bea7bfc78c76",
                    operation="INSERT",
                    pgid="pgtrigger_issue_comment_outbox_insert_bdd46",
                    table="issue_comments",
                    when="AFTER",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="issuecommentproxy",
            trigger=pgtrigger.compiler.Trigger(
                name="issue_comment_outbox_update",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    func="\n                DECLARE\n                    changes JSONB := '{}';\n                    field_name TEXT;\n                    old_value TEXT;\n                    new_value TEXT;\n                    event_type_name TEXT;\n                    enriched_data JSONB;\n                    assignee_ids JSONB;\n                    label_ids JSONB;\n                    issue_data JSONB;\n                BEGIN\n                    -- Check if this is a soft delete (deleted_at changed from null to not null)\n                    IF OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL THEN\n                        -- This is a soft delete\n                        -- Determine delete event type based on issue type\n                        SELECT \n                            CASE \n                                WHEN i.type_id IS NULL THEN 'issue.comment.deleted'\n                                WHEN it.is_epic = true THEN 'epic.comment.deleted'\n                                ELSE 'issue.comment.deleted'\n                            END\n                        INTO event_type_name\n                        FROM issues i\n                        LEFT JOIN issue_types it ON it.id = i.type_id\n                        WHERE i.id = OLD.issue_id;\n                        \n                        -- If no issue found, default to 'issue.comment.deleted'\n                        IF event_type_name IS NULL THEN\n                            event_type_name := 'issue.comment.deleted';\n                        END IF;\n                        \n                        -- Get the complete issue data (excluding description fields)\n                        SELECT to_jsonb(i) - 'description_html' - 'description_binary' - 'description' - 'description_stripped'\n                        INTO issue_data\n                        FROM issues i\n                        WHERE i.id = OLD.issue_id;\n                        \n                        -- Fetch assignee IDs\n                        SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                        INTO assignee_ids\n                        FROM issue_assignees ia\n                        WHERE ia.issue_id = OLD.issue_id AND ia.deleted_at IS NULL;\n                        \n                        -- Fetch label IDs\n                        SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                        INTO label_ids\n                        FROM issue_labels il\n                        WHERE il.issue_id = OLD.issue_id AND il.deleted_at IS NULL;\n                        \n                        -- Create enriched data with complete issue, assignee IDs, and label IDs\n                        enriched_data := issue_data || jsonb_build_object(\n                            'assignee_ids', assignee_ids,\n                            'label_ids', label_ids\n                        );\n                        \n                        BEGIN\n                            INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                            VALUES (\n                                gen_random_uuid(),\n                                event_type_name,\n                                'issue',\n                                OLD.issue_id,\n                                OLD.workspace_id,\n                                OLD.project_id,\n                                jsonb_build_object('data', enriched_data, 'previous_attributes', row_to_json(OLD)),\n                                now(),\n                                NEW.updated_by_id,\n                                COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                            )\n                            ON CONFLICT DO NOTHING;\n                        EXCEPTION\n                            WHEN others THEN\n                                RAISE WARNING 'Outbox delete failed for issue_comment %, reason: %',\n                                             OLD.issue_id, SQLERRM;\n                        END;\n                    ELSE\n                        -- This is a regular update, check for changes\n                        -- Determine update event type based on issue type\n                        SELECT \n                            CASE \n                                WHEN i.type_id IS NULL THEN 'issue.comment.updated'\n                                WHEN it.is_epic = true THEN 'epic.comment.updated'\n                                ELSE 'issue.comment.updated'\n                            END\n                        INTO event_type_name\n                        FROM issues i\n                        LEFT JOIN issue_types it ON it.id = i.type_id\n                        WHERE i.id = NEW.issue_id;\n                        \n                        -- If no issue found, default to 'issue.comment.updated'\n                        IF event_type_name IS NULL THEN\n                            event_type_name := 'issue.comment.updated';\n                        END IF;\n                        \n                        -- Loop through all columns to detect changes\n                        FOR field_name IN \n                            SELECT column_name \n                            FROM information_schema.columns \n                            WHERE table_name = 'issue_comments' \n                            AND table_schema = 'public'\n                            AND column_name != 'updated_at'  -- Skip updated_at column\n                        LOOP\n                            -- Get old and new values as text to avoid JSON conversion issues\n                            EXECUTE format('SELECT ($1).%I::text, ($2).%I::text', field_name, field_name) \n                            INTO old_value, new_value \n                            USING OLD, NEW;\n                            \n                            -- If values are different, add to changes\n                            IF old_value IS DISTINCT FROM new_value THEN\n                                changes := changes || jsonb_build_object(\n                                    field_name, \n                                    old_value\n                                );\n                            END IF;\n                        END LOOP;\n                        \n                        -- Only insert if there are actual changes\n                        IF jsonb_typeof(changes) = 'object' AND changes != '{}' THEN\n                            -- Get the complete issue data (excluding description fields)\n                            SELECT to_jsonb(i) - 'description_html' - 'description_binary' - 'description' - 'description_stripped'\n                            INTO issue_data\n                            FROM issues i\n                            WHERE i.id = NEW.issue_id;\n                            \n                            -- Fetch assignee IDs\n                            SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                            INTO assignee_ids\n                            FROM issue_assignees ia\n                            WHERE ia.issue_id = NEW.issue_id AND ia.deleted_at IS NULL;\n                            \n                            -- Fetch label IDs\n                            SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                            INTO label_ids\n                            FROM issue_labels il\n                            WHERE il.issue_id = NEW.issue_id AND il.deleted_at IS NULL;\n                            \n                            -- Create enriched data with complete issue, assignee IDs, label IDs, and updated comment\n                            enriched_data := issue_data || jsonb_build_object(\n                                'assignee_ids', assignee_ids,\n                                'label_ids', label_ids,\n                                'comment', row_to_json(NEW)\n                            );\n                            \n                            BEGIN\n                                INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                                VALUES (\n                                    gen_random_uuid(),\n                                    event_type_name, \n                                    'issue',\n                                    NEW.issue_id,\n                                    NEW.workspace_id,\n                                    NEW.project_id,\n                                    jsonb_build_object(\n                                        'data', enriched_data,\n                                        'previous_attributes', changes\n                                    ),\n                                    now(),\n                                    NEW.updated_by_id,\n                                    COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                                )\n                                ON CONFLICT DO NOTHING;\n                            EXCEPTION\n                                WHEN others THEN\n                                    RAISE WARNING 'Outbox update failed for issue_comment %, reason: %',\n                                                 NEW.issue_id, SQLERRM;\n                            END;\n                        END IF;\n                    END IF;\n                    \n                    RETURN NEW;\n                END;\n                ",
                    hash="899438c837ab637cc928d12e382abaadd8ea36a1",
                    operation="UPDATE",
                    pgid="pgtrigger_issue_comment_outbox_update_dc7b2",
                    table="issue_comments",
                    when="AFTER",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="issuelabelproxy",
            trigger=pgtrigger.compiler.Trigger(
                name="issue_label_outbox_insert",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    func="\n                DECLARE\n                    event_type_name TEXT;\n                    enriched_data JSONB;\n                    assignee_ids JSONB;\n                    label_ids JSONB;\n                    previous_label_ids JSONB;\n                    issue_data JSONB;\n                BEGIN\n                    -- Determine event type based on issue type\n                    SELECT \n                        CASE \n                            WHEN i.type_id IS NULL THEN 'issue.label.added'\n                            WHEN it.is_epic = true THEN 'epic.label.added'\n                            ELSE 'issue.label.added'\n                        END\n                    INTO event_type_name\n                    FROM issues i\n                    LEFT JOIN issue_types it ON it.id = i.type_id\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- If no issue found, default to 'issue.label.added'\n                    IF event_type_name IS NULL THEN\n                        event_type_name := 'issue.label.added';\n                    END IF;\n                    \n                    -- Get the complete issue data (excluding description fields)\n                    SELECT to_jsonb(i) - 'description_html' - 'description_binary' - 'description' - 'description_stripped'\n                    INTO issue_data\n                    FROM issues i\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- Fetch assignee IDs\n                    SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                    INTO assignee_ids\n                    FROM issue_assignees ia\n                    WHERE ia.issue_id = NEW.issue_id AND ia.deleted_at IS NULL;\n                    \n                    -- Fetch ALL current label IDs (including the newly added one)\n                    SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                    INTO label_ids\n                    FROM issue_labels il\n                    WHERE il.issue_id = NEW.issue_id AND il.deleted_at IS NULL;\n                    \n                    -- Fetch previous label IDs (excluding the newly added one)\n                    SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                    INTO previous_label_ids\n                    FROM issue_labels il\n                    WHERE il.issue_id = NEW.issue_id AND il.deleted_at IS NULL AND il.id != NEW.id;\n                    \n                    -- Create enriched data with complete issue, assignee IDs, and ALL label IDs (including new one)\n                    enriched_data := issue_data || jsonb_build_object(\n                            'assignee_ids', assignee_ids,\n                            'label_ids', label_ids\n                    );\n                    \n                    -- Create previous attributes with label IDs that existed before the addition\n                    issue_data := issue_data || jsonb_build_object(\n                            'assignee_ids', assignee_ids,\n                            'label_ids', previous_label_ids\n                    );\n                    \n                    BEGIN\n                        INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                        VALUES (\n                            gen_random_uuid(),\n                            event_type_name,\n                            'issue_label',\n                            NEW.issue_id,\n                            NEW.workspace_id,\n                            NEW.project_id,\n                            jsonb_build_object('data', enriched_data, 'previous_attributes', issue_data),\n                            now(),\n                            NEW.created_by_id,\n                            COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                        )\n                        ON CONFLICT DO NOTHING;\n                    EXCEPTION\n                        WHEN others THEN\n                            RAISE WARNING 'Outbox insert failed for issue_label %, reason: %',\n                                         NEW.issue_id, SQLERRM;\n                    END;\n                    RETURN NEW;\n                END;\n                ",
                    hash="e145311ba4d88aa53755fb392e26d2539b67faf4",
                    operation="INSERT",
                    pgid="pgtrigger_issue_label_outbox_insert_a8b0d",
                    table="issue_labels",
                    when="AFTER",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="issuelabelproxy",
            trigger=pgtrigger.compiler.Trigger(
                name="issue_label_outbox_update",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    func="\n                DECLARE\n                    event_type_name TEXT;\n                    enriched_data JSONB;\n                    assignee_ids JSONB;\n                    current_label_ids JSONB;\n                    previous_label_ids JSONB;\n                    issue_data JSONB;\n                    previous_issue_data JSONB;\n                BEGIN\n                    -- Determine event type based on issue type\n                    SELECT \n                        CASE \n                            WHEN i.type_id IS NULL THEN 'issue.label.removed'\n                            WHEN it.is_epic = true THEN 'epic.label.removed'\n                            ELSE 'issue.label.removed'\n                        END\n                    INTO event_type_name\n                    FROM issues i\n                    LEFT JOIN issue_types it ON it.id = i.type_id\n                    WHERE i.id = OLD.issue_id;\n                    \n                    -- If no issue found, default to 'issue.label.removed'\n                    IF event_type_name IS NULL THEN\n                        event_type_name := 'issue.label.removed';\n                    END IF;\n                    \n                    -- Get the complete issue data (excluding description fields)\n                    SELECT to_jsonb(i) - 'description_html' - 'description_binary' - 'description' - 'description_stripped'\n                    INTO issue_data\n                    FROM issues i\n                    WHERE i.id = OLD.issue_id;\n                    \n                    -- Fetch assignee IDs\n                    SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                    INTO assignee_ids\n                    FROM issue_assignees ia\n                    WHERE ia.issue_id = OLD.issue_id AND ia.deleted_at IS NULL;\n                    \n                    -- Fetch current label IDs (excluding the one being removed)\n                    SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                    INTO current_label_ids\n                    FROM issue_labels il\n                    WHERE il.issue_id = OLD.issue_id AND il.deleted_at IS NULL AND il.id != OLD.id;\n                    \n                    -- Fetch ALL label IDs (including the one being removed) for previous_attributes\n                    SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                    INTO previous_label_ids\n                    FROM issue_labels il\n                    WHERE il.issue_id = OLD.issue_id AND il.deleted_at IS NULL;\n                    \n                    -- Create enriched data with complete issue, assignee IDs, and current label IDs (after removal)\n                    enriched_data := issue_data || jsonb_build_object(\n                        'assignee_ids', assignee_ids,\n                        'label_ids', current_label_ids\n                    );\n                    \n                    -- Create previous attributes with complete issue, assignee IDs, and ALL label IDs (including the removed one)\n                    previous_issue_data := issue_data || jsonb_build_object(\n                        'assignee_ids', assignee_ids,\n                        'label_ids', previous_label_ids\n                    );\n                    \n                    BEGIN\n                        INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                        VALUES (\n                            gen_random_uuid(),\n                            event_type_name,\n                            'issue_label',\n                            OLD.issue_id,\n                            OLD.workspace_id,\n                            OLD.project_id,\n                            jsonb_build_object('data', enriched_data, 'previous_attributes', previous_issue_data),\n                            now(),\n                            NEW.updated_by_id,\n                            COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                        )\n                        ON CONFLICT DO NOTHING;\n                    EXCEPTION\n                        WHEN others THEN\n                            RAISE WARNING 'Outbox delete-event failed for issue_label %, reason: %',\n                                         OLD.issue_id, SQLERRM;\n                    END;\n                    RETURN OLD;\n                END;\n                ",
                    hash="da94f8d0b65d794bbdcd02ad9c32e405a31ed823",
                    operation="UPDATE",
                    pgid="pgtrigger_issue_label_outbox_update_47e56",
                    table="issue_labels",
                    when="AFTER",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="issuelinkproxy",
            trigger=pgtrigger.compiler.Trigger(
                name="issue_link_outbox_insert",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    func="\n                DECLARE\n                    event_type_name TEXT;\n                BEGIN\n                    -- Determine event type based on issue type\n                    SELECT \n                        CASE \n                            WHEN i.type_id IS NULL THEN 'issue.link.added'\n                            WHEN it.is_epic = true THEN 'epic.link.added'\n                            ELSE 'issue.link.added'\n                        END\n                    INTO event_type_name\n                    FROM issues i\n                    LEFT JOIN issue_types it ON it.id = i.type_id\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- If no issue found, default to 'issue.link.added'\n                    IF event_type_name IS NULL THEN\n                        event_type_name := 'issue.link.added';\n                    END IF;\n                    \n                    BEGIN\n                        INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                        VALUES (\n                            gen_random_uuid(),\n                            event_type_name,\n                            'issue_link',\n                            NEW.issue_id,\n                            NEW.workspace_id,\n                            NEW.project_id,\n                            jsonb_build_object('data', row_to_json(NEW), 'previous_attributes', '{}'),\n                            now(),\n                            NEW.created_by_id,\n                            COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                        )\n                        ON CONFLICT DO NOTHING;\n                    EXCEPTION\n                        WHEN others THEN\n                            RAISE WARNING 'Outbox insert failed for issue_link %, reason: %',\n                                         NEW.issue_id, SQLERRM;\n                    END;\n                    RETURN NEW;\n                END;\n                ",
                    hash="6a9beceb948afcc96af6431bd69e8c623a10af46",
                    operation="INSERT",
                    pgid="pgtrigger_issue_link_outbox_insert_38eb1",
                    table="issue_links",
                    when="AFTER",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="issuelinkproxy",
            trigger=pgtrigger.compiler.Trigger(
                name="issue_link_outbox_update",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    func="\n                DECLARE\n                    changes JSONB := '{}';\n                    field_name TEXT;\n                    old_value TEXT;\n                    new_value TEXT;\n                    event_type_name TEXT;\n                BEGIN\n                    -- Determine event type based on issue type\n                    SELECT \n                        CASE \n                            WHEN i.type_id IS NULL THEN 'issue.link.updated'\n                            WHEN it.is_epic = true THEN 'epic.link.updated'\n                            ELSE 'issue.link.updated'\n                        END\n                    INTO event_type_name\n                    FROM issues i\n                    LEFT JOIN issue_types it ON it.id = i.type_id\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- If no issue found, default to 'issue.link.updated'\n                    IF event_type_name IS NULL THEN\n                        event_type_name := 'issue.link.updated';\n                    END IF;\n                    \n                    -- Check if this is a soft delete (deleted_at changed from null to not null)\n                    IF OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL THEN\n                        -- This is a soft delete\n                        -- Determine delete event type based on issue type\n                        SELECT \n                            CASE \n                                WHEN i.type_id IS NULL THEN 'issue.link.removed'\n                                WHEN it.is_epic = true THEN 'epic.link.removed'\n                                ELSE 'issue.link.removed'\n                            END\n                        INTO event_type_name\n                        FROM issues i\n                        LEFT JOIN issue_types it ON it.id = i.type_id\n                        WHERE i.id = OLD.issue_id;\n                        \n                        -- If no issue found, default to 'issue.link.removed'\n                        IF event_type_name IS NULL THEN\n                            event_type_name := 'issue.link.removed';\n                        END IF;\n                        \n                        BEGIN\n                            INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                            VALUES (\n                                gen_random_uuid(),\n                                event_type_name,\n                                'issue',\n                                OLD.issue_id,\n                                OLD.workspace_id,\n                                OLD.project_id,\n                                jsonb_build_object('data', '{}', 'previous_attributes', row_to_json(OLD)),\n                                now(),\n                                NEW.updated_by_id,\n                                COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                            )\n                            ON CONFLICT DO NOTHING;\n                        EXCEPTION\n                            WHEN others THEN\n                                RAISE WARNING 'Outbox delete failed for issue %, reason: %',\n                                             OLD.id, SQLERRM;\n                        END;\n                    ELSE\n                        -- This is a regular update, check for changes\n                        -- Loop through all columns to detect changes\n                        FOR field_name IN \n                            SELECT column_name \n                            FROM information_schema.columns \n                            WHERE table_name = 'issue_links' \n                            AND table_schema = 'public'\n                            AND column_name != 'updated_at'  -- Skip updated_at column\n                        LOOP\n                            -- Get old and new values as text to avoid JSON conversion issues\n                            EXECUTE format('SELECT ($1).%I::text, ($2).%I::text', field_name, field_name) \n                            INTO old_value, new_value \n                            USING OLD, NEW;\n                            \n                            -- If values are different, add to changes\n                            IF old_value IS DISTINCT FROM new_value THEN\n                                changes := changes || jsonb_build_object(\n                                    field_name, \n                                    old_value\n                                );\n                            END IF;\n                        END LOOP;\n                        \n                        -- Only insert if there are actual changes\n                        IF jsonb_typeof(changes) = 'object' AND changes != '{}' THEN\n                            BEGIN\n                                INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                                VALUES (\n                                    gen_random_uuid(),\n                                    event_type_name, \n                                    'issue',\n                                    NEW.issue_id,\n                                    NEW.workspace_id,\n                                    NEW.project_id,\n                                    jsonb_build_object(\n                                        'data', row_to_json(NEW),\n                                        'previous_attributes', changes\n                                    ),\n                                    now(),\n                                    NEW.updated_by_id,\n                                    COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                                )\n                                ON CONFLICT DO NOTHING;\n                            EXCEPTION\n                                WHEN others THEN\n                                    RAISE WARNING 'Outbox update failed for issue %, reason: %',\n                                                 NEW.id, SQLERRM;\n                            END;\n                        END IF;\n                    END IF;\n                    \n                    RETURN NEW;\n                END;\n                ",
                    hash="1676b5c913cf9212967a99da830af396e4a58fd4",
                    operation="UPDATE",
                    pgid="pgtrigger_issue_link_outbox_update_0b646",
                    table="issue_links",
                    when="AFTER",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="issueproxy",
            trigger=pgtrigger.compiler.Trigger(
                name="issue_outbox_insert",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    func="\n                DECLARE\n                    event_type_name TEXT;\n                    filtered_new_data JSONB;\n                    assignee_ids JSONB;\n                    label_ids JSONB;\n                BEGIN\n                    -- Determine event type based on issue type\n                    SELECT \n                        CASE \n                            WHEN NEW.type_id IS NULL THEN 'issue.created'\n                            WHEN it.is_epic = true THEN 'epic.created'\n                            ELSE 'issue.created'\n                        END\n                    INTO event_type_name\n                    FROM issue_types it\n                    WHERE it.id = NEW.type_id;\n                    \n                    -- If no issue type found, default to 'issue.created'\n                    IF event_type_name IS NULL THEN\n                        event_type_name := 'issue.created';\n                    END IF;\n                    \n                    -- Fetch assignee IDs\n                    SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                    INTO assignee_ids\n                    FROM issue_assignees ia\n                    WHERE ia.issue_id = NEW.id AND ia.deleted_at IS NULL;\n                    \n                    -- Fetch label IDs\n                    SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                    INTO label_ids\n                    FROM issue_labels il\n                    WHERE il.issue_id = NEW.id AND il.deleted_at IS NULL;\n                    \n                    -- Create filtered NEW data excluding description fields\n                    filtered_new_data := to_jsonb(NEW) - 'description_html' - 'description_binary' - 'description' - 'description_stripped';\n                    \n                    -- Add assignee and label IDs to the data\n                    filtered_new_data := filtered_new_data || jsonb_build_object(\n                        'assignee_ids', assignee_ids,\n                        'label_ids', label_ids\n                    );\n                    \n                    BEGIN\n                        INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                        VALUES (\n                            gen_random_uuid(),\n                            event_type_name,\n                            'issue',\n                            NEW.id,\n                            NEW.workspace_id,\n                            NEW.project_id,\n                            jsonb_build_object(\n                                'data', filtered_new_data,\n                                'previous_attributes', '{}'\n                            ),\n                            now(),\n                            NEW.created_by_id,\n                            COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                        )\n                        ON CONFLICT DO NOTHING;\n                    EXCEPTION\n                        WHEN others THEN\n                            RAISE WARNING 'Outbox insert failed for issue %, reason: %',\n                                         NEW.id, SQLERRM;\n                    END;\n                    RETURN NEW;\n                END;\n                ",
                    hash="346a4d578b066e3933a44ce1cfdaf6ac662195e3",
                    operation="INSERT",
                    pgid="pgtrigger_issue_outbox_insert_0de30",
                    table="issues",
                    when="AFTER",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="issueproxy",
            trigger=pgtrigger.compiler.Trigger(
                name="issue_outbox_update",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    func="\n                DECLARE\n                    changes JSONB := '{}';\n                    field_name TEXT;\n                    old_value TEXT;\n                    new_value TEXT;\n                    event_type_name TEXT;\n                    old_is_epic BOOLEAN := false;\n                    new_is_epic BOOLEAN := false;\n                    conversion_event_name TEXT;\n                    filtered_new_data JSONB;\n                    filtered_old_data JSONB;\n                    assignee_ids JSONB;\n                    label_ids JSONB;\n                    has_non_description_changes BOOLEAN := false;\n                    state_changed BOOLEAN := false;\n                BEGIN\n                    -- Check if this is a soft delete (deleted_at changed from null to not null)\n                    IF OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL THEN\n                        -- This is a soft delete\n                        -- Determine delete event type based on issue type\n                        SELECT \n                            CASE \n                                WHEN OLD.type_id IS NULL THEN 'issue.deleted'\n                                WHEN it.is_epic = true THEN 'epic.deleted'\n                                ELSE 'issue.deleted'\n                            END\n                        INTO event_type_name\n                        FROM issue_types it\n                        WHERE it.id = OLD.type_id;\n                        \n                        -- If no issue type found, default to 'issue.deleted'\n                        IF event_type_name IS NULL THEN\n                            event_type_name := 'issue.deleted';\n                        END IF;\n                        \n                        -- Create filtered OLD data excluding description fields\n                        filtered_old_data := to_jsonb(OLD) - 'description_html' - 'description_binary' - 'description' - 'description_stripped';\n                        \n                        BEGIN\n                            INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                            VALUES (\n                                gen_random_uuid(),\n                                event_type_name,\n                                'issue',\n                                OLD.id,\n                                OLD.workspace_id,\n                                OLD.project_id,\n                                jsonb_build_object('data', '{}', 'previous_attributes', filtered_old_data),\n                                now(),\n                                NEW.updated_by_id,\n                                COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                            )\n                            ON CONFLICT DO NOTHING;\n                        EXCEPTION\n                            WHEN others THEN\n                                RAISE WARNING 'Outbox delete failed for issue %, reason: %',\n                                             OLD.id, SQLERRM;\n                        END;\n                    ELSE\n                        -- This is a regular update, check for changes excluding description fields\n                        -- First, check if there are any non-description field changes\n                        FOR field_name IN \n                            SELECT column_name \n                            FROM information_schema.columns \n                            WHERE table_name = 'issues' \n                            AND table_schema = 'public'\n                            AND column_name NOT IN ('updated_at', 'updated_by_id', 'description_html', 'description_binary', 'description', 'description_stripped')  -- Skip description fields\n                        LOOP\n                            -- Get old and new values as text to avoid JSON conversion issues\n                            EXECUTE format('SELECT ($1).%I::text, ($2).%I::text', field_name, field_name) \n                            INTO old_value, new_value \n                            USING OLD, NEW;\n                            \n                            -- If values are different, add to changes and mark that we have non-description changes\n                            IF old_value IS DISTINCT FROM new_value THEN\n                                has_non_description_changes := true;\n                                changes := changes || jsonb_build_object(\n                                    field_name, \n                                    old_value\n                                );\n                                \n                                -- Check if state field has changed\n                                IF field_name = 'state_id' THEN\n                                    state_changed := true;\n                                END IF;\n                            END IF;\n                        END LOOP;\n                        \n                        -- Only proceed if there are non-description field changes\n                        IF has_non_description_changes THEN\n                            -- Determine event type based on issue type and whether state changed\n                            IF state_changed THEN\n                                -- State has changed, use state-specific event types\n                                SELECT \n                                    CASE \n                                        WHEN NEW.type_id IS NULL THEN 'issue.state.updated'\n                                        WHEN it.is_epic = true THEN 'epic.state.updated'\n                                        ELSE 'issue.state.updated'\n                                    END\n                                INTO event_type_name\n                                FROM issue_types it\n                                WHERE it.id = NEW.type_id;\n                                \n                                -- If no issue type found, default to 'issue.state.updated'\n                                IF event_type_name IS NULL THEN\n                                    event_type_name := 'issue.state.updated';\n                                END IF;\n                            ELSE\n                                -- Regular update, use generic event types\n                                SELECT \n                                    CASE \n                                        WHEN NEW.type_id IS NULL THEN 'issue.updated'\n                                        WHEN it.is_epic = true THEN 'epic.updated'\n                                        ELSE 'issue.updated'\n                                    END\n                                INTO event_type_name\n                                FROM issue_types it\n                                WHERE it.id = NEW.type_id;\n                                \n                                -- If no issue type found, default to 'issue.updated'\n                                IF event_type_name IS NULL THEN\n                                    event_type_name := 'issue.updated';\n                                END IF;\n                            END IF;\n                            \n                            -- Fetch assignee IDs\n                            SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                            INTO assignee_ids\n                            FROM issue_assignees ia\n                            WHERE ia.issue_id = NEW.id AND ia.deleted_at IS NULL;\n                            \n                            -- Fetch label IDs\n                            SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                            INTO label_ids\n                            FROM issue_labels il\n                            WHERE il.issue_id = NEW.id AND il.deleted_at IS NULL;\n                            \n                            -- Create filtered NEW data excluding description fields\n                            filtered_new_data := to_jsonb(NEW) - 'description_html' - 'description_binary' - 'description' - 'description_stripped';\n                            \n                            -- Add assignee and label IDs to the data\n                            filtered_new_data := filtered_new_data || jsonb_build_object(\n                                'assignee_ids', assignee_ids,\n                                'label_ids', label_ids\n                            );\n                            \n                            BEGIN\n                                INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                                VALUES (\n                                    gen_random_uuid(),\n                                    event_type_name, \n                                    'issue',\n                                    NEW.id,\n                                    NEW.workspace_id,\n                                    NEW.project_id,\n                                    jsonb_build_object(\n                                        'data', filtered_new_data,\n                                        'previous_attributes', changes\n                                    ),\n                                    now(),\n                                    NEW.updated_by_id,\n                                    COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                                )\n                                ON CONFLICT DO NOTHING;\n                            EXCEPTION\n                                WHEN others THEN\n                                    RAISE WARNING 'Outbox update failed for issue %, reason: %',\n                                                 NEW.id, SQLERRM;\n                            END;\n                        END IF;\n                        \n                        -- Check if type_id has changed to trigger conversion events (only if there are other changes)\n                        IF has_non_description_changes AND OLD.type_id IS DISTINCT FROM NEW.type_id THEN\n                            -- Determine if old type was epic\n                            IF OLD.type_id IS NOT NULL THEN\n                                SELECT COALESCE(it.is_epic, false) INTO old_is_epic\n                                FROM issue_types it\n                                WHERE it.id = OLD.type_id;\n                            END IF;\n                            \n                            -- Determine if new type is epic\n                            IF NEW.type_id IS NOT NULL THEN\n                                SELECT COALESCE(it.is_epic, false) INTO new_is_epic\n                                FROM issue_types it\n                                WHERE it.id = NEW.type_id;\n                            END IF;\n                            \n                            -- Determine conversion event name\n                            IF old_is_epic = false AND new_is_epic = true THEN\n                                conversion_event_name := 'issue.converted.to_epic';\n                            ELSIF old_is_epic = true AND new_is_epic = false THEN\n                                conversion_event_name := 'epic.converted.to_issue';\n                            END IF;\n                            \n                            -- Insert conversion event if applicable\n                            IF conversion_event_name IS NOT NULL THEN\n                                -- Create filtered NEW data excluding description fields for conversion event\n                                filtered_new_data := to_jsonb(NEW) - 'description_html' - 'description_binary' - 'description' - 'description_stripped';\n                                \n                                -- Add assignee and label IDs to the conversion data\n                                filtered_new_data := filtered_new_data || jsonb_build_object(\n                                    'assignee_ids', assignee_ids,\n                                    'label_ids', label_ids\n                                );\n                                \n                                BEGIN\n                                    INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                                    VALUES (\n                                        gen_random_uuid(),\n                                        conversion_event_name,\n                                        'issue',\n                                        NEW.id,\n                                        NEW.workspace_id,\n                                        NEW.project_id,\n                                        jsonb_build_object(\n                                            'data', filtered_new_data,\n                                            'previous_attributes', jsonb_build_object('type_id', OLD.type_id)\n                                        ),\n                                        now(),\n                                        NEW.updated_by_id,\n                                        COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                                    )\n                                    ON CONFLICT DO NOTHING;\n                                EXCEPTION\n                                    WHEN others THEN\n                                        RAISE WARNING 'Outbox conversion failed for issue %, reason: %',\n                                                     NEW.id, SQLERRM;\n                                END;\n                            END IF;\n                        END IF;\n                    END IF;\n                    \n                    RETURN NEW;\n                END;\n                ",
                    hash="cc98de56ebb2458a3a0ed344c2752e2c9c9e66a2",
                    operation="UPDATE",
                    pgid="pgtrigger_issue_outbox_update_b23e9",
                    table="issues",
                    when="AFTER",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="issuerelationproxy",
            trigger=pgtrigger.compiler.Trigger(
                name="issue_relation_outbox_insert",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    func="\n                DECLARE\n                    event_type_name TEXT;\n                BEGIN\n                    -- Determine event type based on issue type\n                    SELECT \n                        CASE \n                            WHEN i.type_id IS NULL THEN 'issue.relation.added'\n                            WHEN it.is_epic = true THEN 'epic.relation.added'\n                            ELSE 'issue.relation.added'\n                        END\n                    INTO event_type_name\n                    FROM issues i\n                    LEFT JOIN issue_types it ON it.id = i.type_id\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- If no issue found, default to 'issue.relation.added'\n                    IF event_type_name IS NULL THEN\n                        event_type_name := 'issue.relation.added';\n                    END IF;\n                    \n                    BEGIN\n                        INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                        VALUES (\n                            gen_random_uuid(),\n                            event_type_name,\n                            'issue_relation',\n                            NEW.issue_id,\n                            NEW.workspace_id,\n                            NEW.project_id,\n                            jsonb_build_object('data', row_to_json(NEW), 'previous_attributes', '{}'),\n                            now(),\n                            NEW.created_by_id,\n                            COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                        )\n                        ON CONFLICT DO NOTHING;\n                    EXCEPTION\n                        WHEN others THEN\n                            RAISE WARNING 'Outbox insert failed for issue_relation %, reason: %',\n                                         NEW.issue_id, SQLERRM;\n                    END;\n                    RETURN NEW;\n                END;\n                ",
                    hash="9b750c88ffe1a1218dd0fc01e6fe719ddea41f7d",
                    operation="INSERT",
                    pgid="pgtrigger_issue_relation_outbox_insert_29038",
                    table="issue_relations",
                    when="AFTER",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="issuerelationproxy",
            trigger=pgtrigger.compiler.Trigger(
                name="issue_relation_outbox_update",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    func="\n                DECLARE\n                    changes JSONB := '{}';\n                    field_name TEXT;\n                    old_value TEXT;\n                    new_value TEXT;\n                    event_type_name TEXT;\n                BEGIN\n                    -- Determine event type based on issue type\n                    SELECT \n                        CASE \n                            WHEN i.type_id IS NULL THEN 'issue.relation.updated'\n                            WHEN it.is_epic = true THEN 'epic.relation.updated'\n                            ELSE 'issue.relation.updated'\n                        END\n                    INTO event_type_name\n                    FROM issues i\n                    LEFT JOIN issue_types it ON it.id = i.type_id\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- If no issue found, default to 'issue.relation.updated'\n                    IF event_type_name IS NULL THEN\n                        event_type_name := 'issue.relation.updated';\n                    END IF;\n                    \n                    -- Check if this is a soft delete (deleted_at changed from null to not null)\n                    IF OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL THEN\n                        -- This is a soft delete\n                        -- Determine delete event type based on issue type\n                        SELECT \n                            CASE \n                                WHEN i.type_id IS NULL THEN 'issue.relation.removed'\n                                WHEN it.is_epic = true THEN 'epic.relation.removed'\n                                ELSE 'issue.relation.removed'\n                            END\n                        INTO event_type_name\n                        FROM issues i\n                        LEFT JOIN issue_types it ON it.id = i.type_id\n                        WHERE i.id = OLD.issue_id;\n                        \n                        -- If no issue found, default to 'issue.relation.removed'\n                        IF event_type_name IS NULL THEN\n                            event_type_name := 'issue.relation.removed';\n                        END IF;\n                        \n                        BEGIN\n                            INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                            VALUES (\n                                gen_random_uuid(),\n                                event_type_name,\n                                'issue',\n                                OLD.issue_id,\n                                OLD.workspace_id,\n                                OLD.project_id,\n                                jsonb_build_object('data', '{}', 'previous_attributes', row_to_json(OLD)),\n                                now(),\n                                NEW.updated_by_id,\n                                COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                            )\n                            ON CONFLICT DO NOTHING;\n                        EXCEPTION\n                            WHEN others THEN\n                                RAISE WARNING 'Outbox delete failed for issue_relation %, reason: %',\n                                             OLD.issue_id, SQLERRM;\n                        END;\n                    ELSE\n                        -- This is a regular update, check for changes\n                        -- Loop through all columns to detect changes\n                        FOR field_name IN \n                            SELECT column_name \n                            FROM information_schema.columns \n                            WHERE table_name = 'issue_relations' \n                            AND table_schema = 'public'\n                            AND column_name != 'updated_at'  -- Skip updated_at column\n                        LOOP\n                            -- Get old and new values as text to avoid JSON conversion issues\n                            EXECUTE format('SELECT ($1).%I::text, ($2).%I::text', field_name, field_name) \n                            INTO old_value, new_value \n                            USING OLD, NEW;\n                            \n                            -- If values are different, add to changes\n                            IF old_value IS DISTINCT FROM new_value THEN\n                                changes := changes || jsonb_build_object(\n                                    field_name, \n                                    old_value\n                                );\n                            END IF;\n                        END LOOP;\n                        \n                        -- Only insert if there are actual changes\n                        IF jsonb_typeof(changes) = 'object' AND changes != '{}' THEN\n                            BEGIN\n                                INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                                VALUES (\n                                    gen_random_uuid(),\n                                    event_type_name, \n                                    'issue',\n                                    NEW.issue_id,\n                                    NEW.workspace_id,\n                                    NEW.project_id,\n                                    jsonb_build_object(\n                                        'data', row_to_json(NEW),\n                                        'previous_attributes', changes\n                                    ),\n                                    now(),\n                                    NEW.updated_by_id,\n                                    COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                                )\n                                ON CONFLICT DO NOTHING;\n                            EXCEPTION\n                                WHEN others THEN\n                                    RAISE WARNING 'Outbox update failed for issue_relation %, reason: %',\n                                                 NEW.issue_id, SQLERRM;\n                            END;\n                        END IF;\n                    END IF;\n                    RETURN NEW;\n                END;\n                ",
                    hash="9608c3f2dbed5321b912126156537518d34d9c6a",
                    operation="UPDATE",
                    pgid="pgtrigger_issue_relation_outbox_update_0c350",
                    table="issue_relations",
                    when="AFTER",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="moduleissueproxy",
            trigger=pgtrigger.compiler.Trigger(
                name="module_issue_outbox_insert",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    func="\n                BEGIN\n                    BEGIN\n                        INSERT INTO outbox (event_id, event_type, entity_type, entity_id, payload, workspace_id, project_id, created_at, initiator_id, initiator_type)\n                        VALUES (\n                            gen_random_uuid(),\n                            'issue.module.added',\n                            'module_issue',\n                            NEW.issue_id,\n                            jsonb_build_object('data', row_to_json(NEW), 'previous_attributes', '{}'),\n                            NEW.workspace_id,\n                            NEW.project_id,\n                            now(),\n                            NEW.created_by_id,\n                            COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                        )\n                        ON CONFLICT DO NOTHING;\n                    EXCEPTION\n                        WHEN others THEN\n                            RAISE WARNING 'Outbox insert failed for module_issue %, reason: %',\n                                         NEW.issue_id, SQLERRM;\n                    END;\n                    RETURN NEW;\n                END;\n                ",
                    hash="765a7bd190447461b57e28cbc2a5047d2973e059",
                    operation="INSERT",
                    pgid="pgtrigger_module_issue_outbox_insert_4a4e3",
                    table="module_issues",
                    when="AFTER",
                ),
            ),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name="moduleissueproxy",
            trigger=pgtrigger.compiler.Trigger(
                name="module_issue_outbox_update",
                sql=pgtrigger.compiler.UpsertTriggerSql(
                    func="\n                BEGIN\n                    BEGIN\n                        -- Check if this is a soft delete (deleted_at changed from null to not null)\n                        IF OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL THEN\n                            -- This is a soft delete\n                            INSERT INTO outbox (event_id, event_type, entity_type, entity_id, payload, workspace_id, project_id, created_at, initiator_id, initiator_type)\n                            VALUES (\n                                gen_random_uuid(),\n                                'issue.module.removed',\n                                'module_issue',\n                                OLD.issue_id,\n                                jsonb_build_object('data', '{}', 'previous_attributes', row_to_json(OLD)),\n                                OLD.workspace_id,\n                                OLD.project_id,\n                                now(),\n                                NEW.updated_by_id,\n                                COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                            )\n                            ON CONFLICT DO NOTHING;\n                        ELSE\n                            -- This is a regular update\n                            INSERT INTO outbox (event_id, event_type, entity_type, entity_id, payload, workspace_id, project_id, created_at, initiator_id, initiator_type)\n                            VALUES (\n                                gen_random_uuid(),\n                                'issue.module.moved',\n                                'module_issue',\n                                NEW.issue_id,\n                                jsonb_build_object('data', row_to_json(NEW), 'previous_attributes', row_to_json(OLD)),\n                                NEW.workspace_id,\n                                NEW.project_id,\n                                now(),\n                                NEW.updated_by_id,\n                                COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                            )\n                            ON CONFLICT DO NOTHING;\n                        END IF;\n                    EXCEPTION\n                        WHEN others THEN\n                            RAISE WARNING 'Outbox update-event failed for module_issue %, reason: %',\n                                         COALESCE(NEW.issue_id, OLD.issue_id), SQLERRM;\n                    END;\n                    RETURN NEW;\n                END;\n                ",
                    hash="7cc218096c880a14df92c89bdfa84b82e619049e",
                    operation="UPDATE",
                    pgid="pgtrigger_module_issue_outbox_update_9f191",
                    table="module_issues",
                    when="AFTER",
                ),
            ),
        ),
    ]
