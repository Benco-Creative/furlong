import { useCallback, useEffect } from "react";
import { observer } from "mobx-react";
import { useParams } from "next/navigation";
import { FormProvider, useForm } from "react-hook-form";

// plane imports
import { ALL_WIDGETS_Y_AXIS_METRICS_LIST, WIDGET_X_AXIS_PROPERTIES_LIST } from "@plane/constants";
import { useTranslation } from "@plane/i18n";
import { TDashboardWidget } from "@plane/types";
import { setToast, TOAST_TYPE } from "@plane/ui";
import { cn } from "@plane/utils";

// plane web hooks
import { useDashboards, useFlag } from "@/plane-web/hooks/store";

// local components
import { WidgetConfigSidebarAxisConfig } from "./axis-config";
import { WidgetConfigSidebarBasicConfig } from "./basic-config";
import { WidgetConfigSidebarFilters } from "./filters";
import { WidgetConfigSidebarHeader } from "./header";
import { WidgetConfigSidebarStyleConfig } from "./style-config/root";

type Props = {
  className?: string;
  dashboardId: string;
};

export const DashboardsWidgetConfigSidebarRoot: React.FC<Props> = observer((props) => {
  const { className, dashboardId } = props;
  const { workspaceSlug } = useParams();

  // store hooks
  const { getDashboardById } = useDashboards();
  // derived values
  const dashboardDetails = getDashboardById(dashboardId);
  // derived values
  const { isViewModeEnabled, widgetsStore, project_ids } = dashboardDetails ?? {};
  // translation
  const { t } = useTranslation();
  // feature flag
  const isDashboardWidgetsFiltersEnabled = useFlag(workspaceSlug?.toString(), "DASHBOARD_WIDGET_FILTERS");

  const { isEditingWidget: widgetIdToEdit, getWidgetById, toggleEditWidget, toggleDeleteWidget } = widgetsStore ?? {};
  const isEditingWidget = !!widgetIdToEdit;
  const widget = widgetIdToEdit ? getWidgetById?.(widgetIdToEdit) : undefined;
  const {
    asJSON,
    id,
    isConfigurationMissing,
    fetchWidgetData,
    updateWidget,
    x_axis_property,
    y_axis_metric,
    group_by,
    filters,
  } = widget ?? {};
  const shouldShowSidebar = !isViewModeEnabled && !!widgetIdToEdit;

  // form info
  const methods = useForm<TDashboardWidget>();
  const { handleSubmit, reset, setValue } = methods;

  const handleCloseSidebar = useCallback(() => {
    toggleEditWidget?.(null);
  }, [toggleEditWidget]);

  const handleFormSubmit = useCallback(
    async (data: Partial<TDashboardWidget>) => {
      try {
        await updateWidget?.(data);
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { config, ...rest } = data;
        if (!isConfigurationMissing && Object.keys(rest).length) {
          fetchWidgetData?.();
        }
      } catch {
        setToast({
          type: TOAST_TYPE.ERROR,
          title: "Error!",
          message: "Something went wrong. Please try again.",
        });
      }
    },
    [fetchWidgetData, isConfigurationMissing, updateWidget]
  );

  const handleDelete = useCallback(() => {
    if (!id) return;
    toggleDeleteWidget?.(id);
  }, [id, toggleDeleteWidget]);

  useEffect(() => {
    if (!isEditingWidget || !asJSON) return;
    reset({
      ...asJSON,
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [asJSON, isEditingWidget]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === "Escape") {
        e.preventDefault();
        handleCloseSidebar();
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, [handleCloseSidebar]);

  useEffect(() => {
    if (isConfigurationMissing || widget?.name !== "New widget") return;

    const generateWidgetName = () => {
      if (group_by) {
        return [
          group_by ? t(WIDGET_X_AXIS_PROPERTIES_LIST[group_by].i18n_label) : undefined,
          x_axis_property ? t(WIDGET_X_AXIS_PROPERTIES_LIST[x_axis_property].i18n_label) : undefined,
        ]
          .filter(Boolean)
          .join(" by ")
          .trim();
      }

      return [
        y_axis_metric ? t(ALL_WIDGETS_Y_AXIS_METRICS_LIST[y_axis_metric].i18n_label) : undefined,
        x_axis_property ? t(WIDGET_X_AXIS_PROPERTIES_LIST[x_axis_property].i18n_label) : undefined,
      ]
        .filter(Boolean)
        .join(" vs ")
        .trim();
    };

    const autoGeneratedInitialName = generateWidgetName();

    if (autoGeneratedInitialName) {
      setValue("name", autoGeneratedInitialName);
      handleFormSubmit({ name: autoGeneratedInitialName });
    }
  }, [isConfigurationMissing, widget?.name, x_axis_property, y_axis_metric, group_by, t, setValue, handleFormSubmit]);

  return (
    <form
      onSubmit={handleSubmit(handleFormSubmit)}
      className={cn(className, "w-[308px] -mr-[308px] flex flex-col gap-y-4 p-4 transition-all", {
        "mr-0": shouldShowSidebar,
      })}
    >
      <FormProvider {...methods}>
        <WidgetConfigSidebarHeader handleClose={handleCloseSidebar} handleDelete={handleDelete} />
        <WidgetConfigSidebarBasicConfig handleSubmit={handleFormSubmit} />
        <div className="flex-shrink-0 h-px bg-custom-background-80" />
        <WidgetConfigSidebarAxisConfig handleSubmit={handleFormSubmit} />
        <div className="flex-shrink-0 h-px bg-custom-background-80" />
        <WidgetConfigSidebarStyleConfig handleSubmit={handleFormSubmit} />
        <div className="flex-shrink-0 h-px bg-custom-background-80" />
        {isDashboardWidgetsFiltersEnabled && (
          <WidgetConfigSidebarFilters
            handleSubmit={handleFormSubmit}
            projectIds={project_ids}
            initialFilters={filters ?? undefined}
          />
        )}
      </FormProvider>
    </form>
  );
});
